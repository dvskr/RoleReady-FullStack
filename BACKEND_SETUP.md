# RoleReady Hybrid Backend Setup

This project uses a hybrid backend approach combining Python and Node.js for optimal performance and functionality.

## Architecture Overview

### üêç Python Backend (Port 8000)
- **FastAPI** framework
- Handles **AI operations** and **authentication**
- Endpoints:
  - `/api/auth/*` - User authentication (login, register, profile)
  - `/api/ai/*` - AI content generation and resume analysis
  - `/health` - Health check

### üü¢ Node.js Backend (Port 3001)
- **Fastify** framework
- Handles **user data** and **resume management**
- Endpoints:
  - `/api/users/*` - User profile management
  - `/api/resumes/*` - Resume CRUD operations
  - `/api/jobs/*` - Job tracking functionality
  - `/api/cloud/*` - Cloud storage operations
  - `/health` - Health check

### ‚öõÔ∏è Frontend (Port 3000)
- **Next.js** application
- Consumes both backend APIs
- Landing page with authentication
- Dashboard with resume builder

## Quick Start

### Option 1: Start All Services
```bash
# From project root
node start-backends.js
```

### Option 2: Start Individual Services

#### Python Backend
```bash
cd apps/api-python
python start.py
```

#### Node.js Backend
```bash
cd apps/api
node start.js
```

#### Frontend
```bash
cd apps/web
npm run dev
```

## API Endpoints

### Python Backend (AI & Auth)
- `POST /api/auth/register` - User registration
- `POST /api/auth/login` - User login
- `GET /api/auth/me` - Get current user
- `POST /api/ai/generate` - Generate AI content
- `POST /api/ai/analyze-resume` - Analyze resume

### Node.js Backend (Data & Storage)
- `GET /api/users/profile` - Get user profile
- `GET /api/resumes` - List user resumes
- `POST /api/resumes` - Save resume
- `GET /api/jobs` - List job applications
- `POST /api/jobs` - Save job application
- `POST /api/cloud/save` - Save to cloud storage
- `GET /api/cloud/list` - List cloud saves

## Authentication Flow

1. **Registration/Login**: Handled by Python backend
2. **JWT Token**: Generated by Python backend
3. **API Calls**: Frontend includes JWT token in headers
4. **User Data**: Stored and managed by Node.js backend
5. **AI Operations**: Processed by Python backend

## Development

### Adding New Features

#### AI Features (Python)
- Add endpoints to `apps/api-python/main.py`
- Update requirements.txt if new packages needed
- Use FastAPI decorators for authentication

#### Data Features (Node.js)
- Add endpoints to `apps/api/src/server.ts`
- Update package.json for new dependencies
- Use Fastify JWT plugin for authentication

#### Frontend Integration
- Update `apps/web/src/services/api.ts`
- Add new API calls to appropriate service
- Update components to use new functionality

## Environment Variables

### Python Backend
```bash
JWT_SECRET=your-jwt-secret
PORT=8000
HOST=0.0.0.0
```

### Node.js Backend
```bash
JWT_SECRET=your-jwt-secret
PORT=3001
HOST=localhost
FRONTEND_URL=http://localhost:3000
```

### Frontend
```bash
NEXT_PUBLIC_PYTHON_API_URL=http://localhost:8000
NEXT_PUBLIC_NODE_API_URL=http://localhost:3001
```

## Production Deployment

### Python Backend
- Use Gunicorn or Uvicorn workers
- Set up proper JWT secrets
- Configure CORS for production domains

### Node.js Backend
- Use PM2 or similar process manager
- Set up database connections
- Configure proper logging

### Frontend
- Build static files with `npm run build`
- Serve with Nginx or similar
- Configure environment variables

## Benefits of Hybrid Approach

1. **Python Backend**: Excellent for AI/ML operations, data science libraries
2. **Node.js Backend**: Fast I/O operations, real-time features, JavaScript ecosystem
3. **Separation of Concerns**: Each backend handles what it does best
4. **Scalability**: Scale each backend independently based on load
5. **Development Speed**: Use the best tools for each task

## Troubleshooting

### Port Conflicts
- Ensure ports 3000, 3001, and 8000 are available
- Check if other services are running on these ports

### CORS Issues
- Verify CORS configuration in both backends
- Check frontend URL in backend CORS settings

### Authentication Issues
- Ensure JWT secrets match between backends
- Check token expiration settings
- Verify token format in API calls

### Database Issues
- Check database connection strings
- Ensure database is running and accessible
- Verify table schemas match expectations
